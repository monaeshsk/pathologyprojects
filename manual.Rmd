---
title: "NewModelEDA"
output: html_document
---

```{r}

library(readr)


#Manipulation
library(dplyr)
library(sjmisc)
library(scales)
library(splitstackshape)

#Text mining
library(quanteda)
library(tm)
library(sylcount)
library(stringr)
#library(shiny)

#Kmeans
library(cluster)
library(factoextra)


#model
library(caret)
library(glmnet)
```


```{r}
Histo <- read_csv("Histo_ClinHx_Speci_Descn_Analysis_2019.csv")
Histo <- read_csv("BloodCultureClinHxSpeciDesc2015-2020.csv")
```




```{r}

##LEVEL 1, No information

#Dealing with NA values
lowlvl <- 1

Histo$Rating <- NA
Histo[is.na(Histo$ClinHx),]$Rating <- 1

#Dealing with punctuations and blank strings
Histo$ClinHx <- removePunctuation(Histo$ClinHx)
Histo[which(Histo$ClinHx == ''),]$Rating <- 1
#Histo$Rating <- as.numeric(Histo$Rating)

#Removing all the single character entries
Histo[which(nchar(Histo$ClinHx) <= 2),]$Rating <- 1


#Setting all the invalids that may be characters into Rating
Histo[grep("nil", tolower(Histo$ClinHx)),]$Rating <- 1
Histo[grep("na", tolower(Histo$ClinHx)),]$Rating <- 1
Histo[grep("nan", tolower(Histo$ClinHx)),]$Rating <- 1
Histo$Rating <- as.numeric(Histo$Rating)
```

```{r}
table(Histo$Rating)
```



```{r}
#Setting all the References to other information as level 2 
#remove name changes the ranking of the value inserted into 2 
remove_name <- function(name){
  list <- (Histo[grep(name, tolower(Histo$ClinHx)),]$ClinHx)
  list <- as.data.frame(list)
  list$row <- grep(name, tolower(Histo$ClinHx))
  list <- list[which(sapply(strsplit(list$list, "\\s+"), length)<=5),]
  Histo[as.numeric(list$row),]$Rating <- 2
  return(Histo)
}

Histo <- remove_name(name = 'form')
Histo <- remove_name(name = 'clinical')
Histo <- remove_name(name = 'refer')
Histo <- remove_name(name = 'histo')
Histo <- remove_name(name = 'notes')
Histo <- remove_name(name = 'request')
Histo <- remove_name(name = 'scanned')
Histo <- remove_name(name = 'attached')
Histo <- remove_name(name = 'image')
```


```{r}
#summary(histo_rules)
```

```{r}
##Creating random samples from data
set.seed(1234)
Histo_unranked <- Histo[which(is.na(Histo$Rating)),]
#
#to be updated with past model predictions

#Histo_unranked$read <- (textstat_readability(Histo_unranked$ClinHx, measure ='Bormuth.MC'))$Bormuth.MC

#
Histo_unranked$length <- ntoken(Histo_unranked$ClinHx)
#distance <- dist(Histo_unranked[,c('read','length')])

Histo_unranked <- as.data.frame(Histo_unranked%>% select(length, ClinHx))
k4 <- kmeans(Histo_unranked %>% select(length), centers = 4, nstart = 25)
Histo_unranked$cluster <- k4$cluster
#Histo_unranked[which(Histo_unranked$cluster ==1),]
histo_strat <- stratified(Histo_unranked, 'cluster', 0.02)
histo_strat$UserScore <- NA
histo_strat <- histo_strat[order(-histo_strat$length),]
histo_strat$UserScore <- round(rescale(histo_strat$length, to = c(0,10)),0)
write.csv(histo_strat %>% select(ClinHx, UserScore),"RANKBLOOD.csv", row.names = TRUE)

```


Creating wordlist hash table
```{r}
wordlist <- read_csv("wordlist/wordlist.csv", col_names = FALSE)
wordlist$X1 <- tolower(wordlist$X1)
wordlisthash <- hash(keys =  wordlist$X1, values = wordlist$X1)
```



```{r}
#Creating Regressor with readability measures
sample <- read_csv("RANKBLOOD.csv")

#measure_list <- c("ARI","Bormuth.MC","Bormuth.GP","Coleman","Coleman.C2","Coleman.Liau.ECP","Coleman.Liau.grade","Coleman.Liau.short","Dale.Chall","Dale.Chall.PSK","Danielson.Bryan","Dickes.Steiwer","DRP","ELF","Farr.Jenkins.Paterson","Flesch","Flesch.PSK","Flesch.Kincaid","FOG","FOG.PSK","FOG.NRI","FORCAST","FORCAST.RGL","Fucks","Linsear.Write","LIW","nWS","nWS.2","nWS.3","nWS.4","RIX","Scrabble","SMOG","SMOG.C","SMOG.simple","Spache","Spache.old","Strain","Traenkle.Bailer","Wheeler.Smith","meanSentenceLength","meanWordSyllables")


#FUNCTION TO REMOVE DUPLICATE WORDS FROM EACH ROW 
rem_dup.one <- function(x){
  paste(unique(tolower(trimws(unlist(strsplit(x,split="(?!')[ [:punct:]]",fixed=F,perl=T))))),collapse = " ")
}
rem_dup.vector <- Vectorize(rem_dup.one,USE.NAMES = FALSE)
sample$ClinHx <- rem_dup.vector(sample$ClinHx)

#FUNCTION TO REMOVE STOPWORDS
rm_words <- function(string, words) {
    stopifnot(is.character(string), is.character(words))
    spltted <- strsplit(string, " ", fixed = TRUE) # fixed = TRUE for speedup
    vapply(spltted, function(x) paste(x[!tolower(x) %in% words], collapse = " "), character(1))
}



rem_dup.vector <- Vectorize(rem_dup.one,USE.NAMES = FALSE)
sample$ClinHx <- rem_dup.vector(sample$ClinHx)
sample$ClinHx <- rm_words(sample$ClinHx, stopwords('english'))


create_read_dataframe_test<- function(set){
  read_counts <- sylcount::doc_counts(set$ClinHx)
  if (mean(read_counts$sents) == 0){read_counts <- read_counts %>% select(-sents)}
  if (mean(read_counts$nonwords) == 0){read_counts <- read_counts %>% select(-nonwords)}
  tokens <- tokens(sample$ClinHx, remove_separators = TRUE)
  docnames(tokens) <- 'text'
  word_in_dict <- c()
  for (i in seq_along(tokens)){
    x <- as.list(tokens[i])
    x <- x$text
    z = has.key(key =x, hash = wordlisthash)
    word_in_dict[i] <- length(z[z== TRUE])
  }
  read <- data.frame(set$ClinHx, set$UserScore, read_counts, word_in_dict)
  colnames(read)[1:2] <- c('ClinHx', 'actual')
return(read)
}

create_read_dataframe<- function(set){
  read_counts <- sylcount::doc_counts(set$ClinHx)
  if (mean(read_counts$sents) == 0){read_counts <- read_counts %>% select(-sents)}
  if (mean(read_counts$nonwords) == 0){read_counts <- read_counts %>% select(-nonwords)}
  tokens <- tokens(set$ClinHx, remove_separators = TRUE)
  docnames(tokens) <- 'text'
  word_in_dict <- c()
  #for (i in seq_along(tokens)){
   # x <- as.list(tokens[i])
    #x <- x$text
    #z = has.key(key =x, hash = wordlisthash)
    #word_in_dict[i] <- length(z[z== TRUE])
  #}
  read <- data.frame(set$ClinHx, read_counts)
  colnames(read)[1] <- c('ClinHx')
return(read)
}
read <- create_read_dataframe_test(sample)
#read <- read %>% mutate_if(is.numeric, function(x) ifelse(is.infinite(x), 0, x))



```
```{r}
read$wordCount <- x
read[read$wordCount != 0,]
```



```{r}
cols <- c("chars","wordchars","words","sylls", "polys", 'word_in_dict')
pre_proc_val <- preProcess(read[,cols], method = c("center", "scale"))
read[,cols] = predict(pre_proc_val, read[,cols])

#summary(read)
lr <- lm(actual~chars+wordchars+words+sylls+polys, data = read)    
RMSE((predict(lr)), read$actual)
#cbind(round(predict(lr)), read$actual)
```


```{r}
cols <- c('actual',"chars","wordchars","words","sylls", "polys")
dummies <- dummyVars(actual~.,data = read[,cols])
dummies <- predict(dummies, newdata = read[,cols])
dim(dummies)
dummies <- as.matrix(dummies)
lambdas <- 10^seq(2, -3, by = -.1)

cv_ridge <- cv.glmnet(dummies, read$actual, alpha = 1, lambda = lambdas)
lambda <- cv_ridge$lambda.min


ridge_reg = glmnet(dummies, read$actual, nlambda = 25, alpha = 1, family = 'gaussian', lambda = lambda)
summary(ridge_reg)
```
```{r}
RMSE(predict(ridge_reg, s = lambda, newx=dummies), read$actual)
coef(ridge_reg)
```


```{r}

#Selecting best readability model
read_subset <- read[,-1]
read_subset <- read_subset %>% mutate_if(is.numeric, list(~na_if(., Inf)))


lm0 <- lm(actual ~ 1, data = read_subset)
lmall <- lm(actual ~ ., data = read_subset)
lmfwd <- step(lm0, scope = formula(lmall), direction = "forward", trace = 0)
fwd_predict <- predict(lmfwd)
plot(read_subset$actual, fwd_predict)
#plot(read_subset$actual, scales::rescale(read_subset$Bormuth.MC, to = c(0,10)))
```

```{r}
plot(lmfwd)
formula(lmfwd)
```

```{r}
summary(lmfwd)
Histo$rows <- rownames(Histo) 
Histo_unranked_model <- Histo[is.na(Histo$Rating),]
Histo_read <- create_read_dataframe(Histo_unranked_model)
#summary(lm(read$actual~read$Bormuth.MC))
Histo_unranked_model$Rating <- round(predict(lmfwd, newdata = Histo_read))
Histo_unranked_model[which(Histo_unranked_model$Rating <=5),]$Rating <- 3
Histo_unranked_model[which(Histo_unranked_model$Rating >5),]$Rating <- 4

```

```{r}
Histo_final <- Histo[!is.na(Histo$Rating),]
Histo_final <- rbind(Histo_final, Histo_unranked_model)
Histo_final$Rating <- as.character(Histo_final$Rating)
Histo_final[which(Histo_final$Rating==1),]$Rating <- 'no information'
Histo_final[which(Histo_final$Rating==2),]$Rating <- 'reference to any information'
Histo_final[which(Histo_final$Rating==3),]$Rating <- 'low quality clinical history'
Histo_final[which(Histo_final$Rating==4),]$Rating <- 'high quality clinical history'
Histo_final$Rating <- as.factor(Histo_final$Rating)

```


```{r}
write.csv(Histo_final$Rating, file = 'final.csv')
```

```{r}
ggplot()+
  ggplot2::geom_histogram(aes = table(Histo_final$Rating))
```

```{r}
RMSEP <- function(predict,actual){
  return (sqrt(sum((predict -actual)^2)/length(predict)))
}
RMSEP(predict(lr), train$actual)
RMSE(predict(lr), train$actual)
```


